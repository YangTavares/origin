% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{CSUEB FPGA Documentation}
\date{Aug 07, 2016}
\release{1.0}
\author{Yang Azevedo Tavares}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{FPGA Project Description}
\label{intro:fpga-project-description}\label{intro::doc}\label{intro:welcome-to-csueb-fpga-s-documentation}
\noindent\sphinxincludegraphics{{bookcover}.jpg}

The architecture that is about to be presented is based on the book “Architecture and CAD for Deep-Submicron FPGAs”, also on several discussions and available time to be accomplished.

The FPGA will have only one tipe of Tile, 1 lenght wires, a channel width of 16 and wilton switch block.

This project is being developed on California State University, East Bay and is beeing supervised by professor James Tandon from Department of Engineering.


\chapter{SRAM}
\label{index:sram}
To control several components that are important for the FPGA, we will need SRAM cells.  The sizing of each transistor on the SRAM is very important so it can hold the information and show it when doing common operations. There is a section on the book “CMOS VLSI Design a Circuits and Systems Perspective” which describes the proper sizing of a SRAM cell; it worked well for our simulations. 16 bits will program the SRAM cells on the FPGA each time.


\section{Managing SRAM on FPGA}
\label{readwrite:managing-sram-on-fpga}\label{readwrite::doc}
\noindent\sphinxincludegraphics{{programSRAMs}.png}

To program the SRAM cells on the tile, there will be a decoder choosing each single array of 16 cells per time, it is needed to manage the operations properly so the data on the cells will be written when needed. Each time you use one device on the figure, its needed to enable it and disable all others except the Decoder enable, it is only needed to disable the Decoder when the Address needs to be changed.


\subsection{SRAM cell schematic}
\label{sramcell:sram-cell-schematic}\label{sramcell::doc}
The SRAM cells are capable of storing a bit (0-1) for each cell

\noindent\sphinxincludegraphics{{SRAM_cell}.png}

(Schematic taken from Sue)

“DATA” represents the bit stored in the SRAM cell on the image above. To change the value of the “DATA”, it is needed to enable the ``WORD'' line with a logical 1 and drive the ``BIT'' line with the proper value and the ``NOTBIT'' line with inverted value, so it will be electrically forced to change.

The sizing of each transistor at the cell is defined by the book ``CMOS VLSI Design'' which says the pull up, pull down and pass transistors should have 3/3, 8/2, 4/2 of sizing respectively. These sizes are important so the SRAM cell can hold its value when needed, but not being weak when the read operation is being executed.


\subsection{Sense Amplifier schematic}
\label{senseamp::doc}\label{senseamp:sense-amplifier-schematic}
\noindent\sphinxincludegraphics{{Sense_amp}.png}

(Schematic taken from Sue)

The figure shown above is a Sense Amplifier which is used to read the current data stored in the SRAM cell, to do so, both ``BIT'' and ``NOTBIT'' needs to be pulled high and them tri-stated, after this the Sense will be enabled to read by pulling the SE down, it will be able to sense which of the bit lines have higher voltage and them amplify it.

\noindent\sphinxincludegraphics{{sense_tri}.png}

(Schematic taken from Sue)

Outside each Sense Amplifier, there will be a tri-state buffer to control the outputs of each Data, as we want to read different cells on each Tile as we program the FPGA. We have 16 of those combinations as we program 16 bits per time.

\noindent\sphinxincludegraphics{{sense_enable}.png}

(Schematic taken from Sue)


\subsection{Write Driver}
\label{writedrive:write-driver}\label{writedrive::doc}
To write the propper values on each desired SRAM cell, two tri-state inverters with a inverter coupled on one are used to drive both BIT and BITBAR

\noindent\sphinxincludegraphics{{write_driver}.png}

(Schematic taken from Sue)

As we have 16 bits to program at each time, its used a series of 16 drivers on each SRAM controller

\noindent\sphinxincludegraphics{{write_enable}.png}

(Schematic taken from Sue)

It also has a ``Write\_Enable'' for controlling the tri-state buffers, as we will have to program different cells on other Tiles.


\subsection{Pull up System}
\label{pullupbit::doc}\label{pullupbit:pull-up-system}
At the read operation, both ``BIT'' and ``NOTBIT'' must be pulled to a logical 1 so the Sense Amplifier can operate on reading if the SRAM stores a logical 0 or 1. for that, we are using a pmos transistor that is activated when the ``Pull\_Read'' port is activated

\noindent\sphinxincludegraphics{{pull_bit}.png}

(Schematic taken from Sue)

Because we were having an issue with isolated pmos on the layout, we coupled a nmos transistor with the gate floating so there would be no DRC errors.

\noindent\sphinxincludegraphics{{pull_array}.png}

(Schematic taken from Sue)

Using 32 of them to raise all the ``BIT'' and ``NOTBIT'' lines


\subsection{Decoder System}
\label{decodersystem:decoder-system}\label{decodersystem::doc}
The Decoder is in 2x4 configuration and it also has an ``Enable'' port that allows the easy expansion to bigger Decoders.

\noindent\sphinxincludegraphics{{decoder_serie}.png}

(Schematic taken from Sue)

Inside the 2x4 Decoder, it is used 4 3-And gates and 2 Inverters as shown.

\noindent\sphinxincludegraphics{{decoder_inside}.png}

(Schematic taken from Sue)


\subsection{Write Operation}
\label{writeoperation::doc}\label{writeoperation:write-operation}
To Write a value on a SRAM cell at a specific location, the Word from the desired place must be enabled, and then the value to be written must also be chosen. It is important that the value chosen to be written must be extended after the Decoder is disabled, so the SRAM cell wont get a random value at the end.

\noindent\sphinxincludegraphics{{write_operation}.png}

(Simulation taken from EzWave)

It is being written a logical 1 at the selected ``WORD'' on the Tile, the ``WORD'' drives 16 bits of information.


\subsection{Read Operation}
\label{readoperation::doc}\label{readoperation:read-operation}
To Read a value from a SRAM cell, it is needed first to pull both BIT and NOTBIT high, and then enable the Sense Amplifiers to output the bit value.

\noindent\sphinxincludegraphics{{write_operation}.png}

(Simulation taken from EzWave)

\noindent\sphinxincludegraphics{{SRAM_outside}.png}

(Block vision taken from Sue)

\noindent\sphinxincludegraphics{{SRAM_inside}.png}

(Inside the SRAM manager block)


\chapter{Tile Structure}
\label{index:tile-structure}
The basic logic structure of the FPGA called ``Control Logic Block'' (Referenced here as Tile) can be programmed to be any logic gate or combination of logic gates with N inputs, which can be synchronous or asynchronous and after, many Tiles can be connected to form bigger circuits.


\section{Tile}
\label{tile:tile}\label{tile::doc}
We  are going to implement an FPGA with a single type of a Tile, which will have four LUTs (Look-Up-Table) inside (N = 4) and each LUT will have four inputs (K = 4), each output of the LUT will be connected to a D flip flop and after, a mux can choose between the D flip flop output or directly from the LUT (Block Logic Element) . Studies presented on the book have shown that LUTs with 4-inputs leads to FPGAs with the highest area-efficiency, and most commercial FPGAs are based on 4-input LUTs, also, Tiles consisting of multiple LUTs will have a better area efficiency.

\noindent\sphinxincludegraphics{{fullyconnectbook}.jpg}

(Fully connected cluster. Figure from the book)

\noindent\sphinxincludegraphics{{TileDistribution}.png}

The positioning of the pins around the Tile will be a full-perimeter configuration, which means it will be evenly distributed around the square to achieve the best area-efficiency. Each Tile will have Global wirings to program the SRAMs cells and to control the four different possible clocks to the registers, each Tile can only have one clock.


\subsection{LUT structure}
\label{lut:lut-structure}\label{lut::doc}
\noindent\sphinxincludegraphics{{LUT}.png}

The figure shown above is the drawing of the LUT configuration; it is a MUX that chooses between 16 signals over 16 SRAM cells, so it can be programmed to be any logic gate or combination of logic gates that has 4 inputs and one output.


\subsubsection{LUT Mux}
\label{muxstruct:lut-mux}\label{muxstruct::doc}
The mux configuration structure for the LUT is created using tri-state-inverters for the first stage and then pass transistors for the last 3 stages, at the end there is a inverter to reverse the tri-state-inverter output

\noindent\sphinxincludegraphics{{tri_stage}.png}

(Schematic taken from Sue)

\noindent\sphinxincludegraphics{{mux_stage}.png}

(Schematic taken from Sue)

Since the pass transistor outputs a weak logical 1, it is used level shifters to boots the gate voltages and enhance the Mux properties, for each stage there is input drivers to manage each stage and output the propper value.

\noindent\sphinxincludegraphics{{input_driver}.png}

(Schematic taken from Sue)

\noindent\sphinxincludegraphics{{mux_inside}.png}

(Schematic taken from Sue)


\subsubsection{Level Shifter}
\label{levelshift::doc}\label{levelshift:level-shifter}
The level shifter is a important circuit that raises up the main voltage, since we are using only a pass transistor to control the flow of the Mux, it is needed to raise the voltage of the gate so the transitor can output the high signal with full power.

\noindent\sphinxincludegraphics{{level_shifter}.png}

(Schematic taken from Sue)

It is important that the pull down transistors are larger than normal because since the pmos transistors are cross-coupled, they will have more power at the circuit.

This schematic configuration was taken from the paper \url{http://rgjournals.com/index.php/ijse/article/viewFile/430/214}

After some tests and simulations with the presented circuit, we have compared the output voltage, the rise time, and the standby current as shown on the following images:

\noindent\sphinxincludegraphics{{gate_boost}.png}

\noindent\sphinxincludegraphics{{stand_current}.png}

Observing the graphic, the VDDH voltage for the FPGA chosen is 1.8V.

\noindent\sphinxincludegraphics{{LUT_outside}.png}

(Block view of the LUT, Schematic taken from Sue)

\noindent\sphinxincludegraphics{{LUT_inside}.png}

(Inner view of the LUT, Schematic taken from Sue)


\subsection{Block Logic Element}
\label{ble::doc}\label{ble:block-logic-element}
\noindent\sphinxincludegraphics{{LUTwithRegister}.png}

The figure above shows the BLE schematic, it is a MUX that can choose between the direct output of the LUT or the registered version controlled by a clock; it is useful for creating circuits that can be synchronous or asynchronous.

\noindent\sphinxincludegraphics{{ble}.png}

(Schematic taken from Sue)

The last image shows 4 LUTS that are connected with 4 flipflops separately, at the end there is a mux for all the components, choosing the output of the LUT or the flip-flop.


\subsubsection{Flip Flop}
\label{flipflop:flip-flop}\label{flipflop::doc}
The flip flop design was implemented to be the smallest area performance

\noindent\sphinxincludegraphics{{true_flip}.png}

(Schematic taken from Sue)

This is a ``true single-phase edge-triggered flip-flop with reset''.


\subsubsection{BLE Mux}
\label{blemux::doc}\label{blemux:ble-mux}
The ble mux uses only one stage of pass transistors that are boosted by level shifters, it is only needed 1 SRAM to control which pass transistor is chosen.

\noindent\sphinxincludegraphics{{blemux}.png}

(Schematic taken from Sue)


\subsection{LUT Input Mux}
\label{lutinput:lut-input-mux}\label{lutinput::doc}
\noindent\sphinxincludegraphics{{lut_input}.png}

(Schematic taken from Sue)

The LUT Input Mux is used to make a possible connection with all the Tile inputs and outputs, so it will be a fully connected Tile

\noindent\sphinxincludegraphics{{lut_input_inside}.png}

(Schematic taken from Sue)

Each input of the LUTs has a 14x1 Mux and they are controlled by 14 SRAM cells each

\noindent\sphinxincludegraphics{{sram_level}.png}

(Schematic taken from Sue)

Each SRAM cell is coupled with a level shifter at the end, so they will control the pass transistors at the Mux

\noindent\sphinxincludegraphics{{mux_input}.png}

The Mux that drives the input of the LUT consists of only one stage of pass transistors (14 in total), their gates are controlled by the SRAM cells and the inputs come from the inputs and outputs from the Tile.


\subsection{Clock Mux}
\label{clockmux:clock-mux}\label{clockmux::doc}
\noindent\sphinxincludegraphics{{4differentclocks}.png}

The Clock Mux will make possible for each Tile to have 4 different options of clock.

\noindent\sphinxincludegraphics{{clock_mux}.png}

(Schematic taken from Sue)

\noindent\sphinxincludegraphics{{clock_mux_inside}.png}

(Schematic taken from Sue)

4 SRAM cells with level shifters are used to control the 4 different pass transistors available.

\noindent\sphinxincludegraphics{{tile_inside}.png}

(Schematic taken from Sue)

\noindent\sphinxincludegraphics{{tile_outside}.png}

(Schematic taken from Sue)


\chapter{Interconnection Structure}
\label{index:interconnection-structure}
After creating the Basic Logic Elements, it is needed to connect them together to create larger circuits.


\section{Interconnect}
\label{interconnect:interconnect}\label{interconnect::doc}
The FPGA needs a way to connect the Tiles together, the Tiles need to connect to the nearest wires (using connection blocks) , and the end of those wires needs to connect to other wires (using switch blocks). The number of tracks on each channel will be 16 and the wires will be unidirectional.


\subsection{Connection Block}
\label{connectionblock:connection-block}\label{connectionblock::doc}
\noindent\sphinxincludegraphics{{connectblock}.png}

(Image taken from VPR viewer)

The FPGA will have similar connection blocks on most of it, The inputs of the Tile will connect up to 4 wires in the 16 possibilities (Fc = 0.25) and the same for the outputs.

The connections will be made with tri-state buffers controlled by SRAM cells.

\noindent\sphinxincludegraphics{{connect_block}.png}

(Schematic taken from Sue)

\noindent\sphinxincludegraphics{{full_connect}.png}

(Schematic taken from Sue)


\subsection{Switch Block}
\label{switchblock:switch-block}\label{switchblock::doc}
\noindent\sphinxincludegraphics{{wilton}.png}

(This image was generated by VPR visualizer)

The switch block will connect the wires together over the channels in the FPGA making routing possible. We are going to use wilton switch block, it connects to a different wire number at least one time, each wire can connect up to 3 wires (Fs = 3).

\noindent\sphinxincludegraphics{{switch_block}.png}

(Schematic taken from Sue)

The switch block has 3 tri-state buffers for each wire, and there are 2 types of blocks that interconnect the wires, one for output and other for input, since the wires are unidirectional.

\noindent\sphinxincludegraphics{{in_block}.png}

(A wire that can receive from 3 different wires, Schematic from Sue)

\noindent\sphinxincludegraphics{{out_block}.png}

(A wire that can drive up to 3 different wires, Schematic from Sue)


\subsection{Block}
\label{block::doc}\label{block:block}
The Block is the basic piece in the FPGA that can be multiplied to create any FPGA size that is desired, because it contains the basic structures for logic and routing

\noindent\sphinxincludegraphics{{Inside_Block}.png}

(Inner view of Block cell, Schematic taken from Sue)

By the way we have implemented, one Block has only 2 channels that were placed on the right and bottom, 2 Connection Blocks for each channel and one Switch Block for the intersection of the channels. A SRAM manager is used to program all the SRAM cells that are used by the different components inside the block

\noindent\sphinxincludegraphics{{block_outside}.png}

(Block view of Block cell, Schematic taken from Sue)

Each block has a ``Enable\_Decoder'' and ``Sense\_Enable'' port that can be enabled to do the propper operations on the Block, the Decoder address, the interconnection wires on all the sides, The Sense Amplifier enable, Pull up bit Enable, Write In bits and Datas from the Sense Amplifiers.

\noindent\sphinxincludegraphics{{blocks_together}.png}

(Blocks connected together, Schematic taken from Sue)

It is needed to create different Tiles for the edges, so they can interconnect with the pads and take care of the extra wires.

\noindent\sphinxincludegraphics{{edge_left}.png}

(An left\_edge Block, Schematic taken from Sue)

For the left\_edge Block, it is needed to put an extra channel at the left, so the left ports of the Tile can have the same logic interconnect of the rest of the FPGA, this requires the block to have more Connections Blocks, Switch Blocks and consequently a larger SRAM manager Decoder.

As for the Bottom, Right and Bottom-Right Edge it is only needed to change the Connection Blocks, to interface the I/O pads as the desired way

\noindent\sphinxincludegraphics{{edge_pad}.png}

In the example above, all the ports at the left side are connected into one wire, it can choose to output to any wire or receive a signal for the possible wires.


\chapter{Programming the FPGA}
\label{index:programming-the-fpga}
After all the basic structure is completed, it is needed to elaborate a way to program the FPGA so it can be transformed in any desired circuit.


\section{Programming}
\label{programming:programming}\label{programming::doc}
There are several steps to program the FPGA, first of all is trying to use the less ports as we can to achieve best the use of I/O pads. Also, it is important to have a way to choose which SRAM cells you want to program per time and how to choose then. At the end, use a software to translate your Verilog program into a Place and Route file that will be transformed into our programming logic for the FPGA.


\subsection{16-bit Accumulator}
\label{16accumulator:bit-accumulator}\label{16accumulator::doc}
A 16-bit Accumulator is used to interface with the ``Write INs'' of the SRAM manager, it is going to reduce the Inputs needed to program the SRAM cells at the FPGA. Also, it is important to have a way to choose which SRAM cells you want to program per time and how to choose then. At the end, use a software to translate your Verilog program into a Place and Route file that will be transformed into our programming logic for the FPGA.

\noindent\sphinxincludegraphics{{16accumulator}.png}

(Schematic taken from Sue)

This piece is made of 16 full-adders and flip-flops, each time the clock rises the input bits are added with the previous value.

\noindent\sphinxincludegraphics{{closer_adder}.png}

(Schematic taken from Sue)

\noindent\sphinxincludegraphics{{16_inside}.png}

(Schematic taken from Sue)


\subsection{FPGA Decoder}
\label{fpgadecoder::doc}\label{fpgadecoder:fpga-decoder}
To program each Block of the FPGA, there will be a big Decoder which outputs will be connected to the ``Enable\_Decoder'' of the Blocks. All the other ports can be connected together, by changing the address it is possible to select a determined block at the FPGA

\noindent\sphinxincludegraphics{{fpga_schem}.png}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
